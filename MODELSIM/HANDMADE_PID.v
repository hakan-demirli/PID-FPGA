// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\untitled\HANDMADE_PID.v
// Created: 2021-03-05 08:22:51
// 
// Generated by MATLAB 9.9 and HDL Coder 3.17
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.000699301
// Target subsystem base rate: 0.000699301
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        0.000699301
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Out1                          ce_out        0.000699301
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HANDMADE_PID
// Source Path: untitled/HANDMADE_PID
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HANDMADE_PID
          (clk,
           reset_x,
           clk_enable,
           PID_OUT,
           ce_out,
           Out1);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   signed [35:0] PID_OUT;  // sfix36_En14
  output  ce_out;
  output  signed [35:0] Out1;  // sfix36_En14


  wire enb;
  wire signed [35:0] kconst;  // sfix36_En27
  reg signed [35:0] kconst_1;  // sfix36_En27
  reg signed [35:0] PID_OUT_1;  // sfix36_En14
  wire signed [71:0] Gain_mul_temp;  // sfix72_En41
  wire signed [35:0] Gain_out1;  // sfix36_En14
  reg signed [35:0] delayMatch1_reg [0:2];  // sfix36 [3]
  wire signed [35:0] delayMatch1_reg_next [0:2];  // sfix36_En14 [3]
  wire signed [35:0] Gain_out1_1;  // sfix36_En14
  wire Discrete_Time_Integrator_reg_ctrl_co_1;
  reg  [0:4] delayMatch_reg;  // ufix1 [5]
  wire [0:4] delayMatch_reg_next;  // ufix1 [5]
  wire Discrete_Time_Integrator_reg_ctrl_de;
  wire signed [35:0] Discrete_Time_Integrator_reg_Initial_1;  // sfix36_En14
  wire signed [35:0] kconst_2;  // sfix36_En44
  reg signed [35:0] kconst_3;  // sfix36_En44
  wire signed [35:0] kconst_4;  // sfix36_En21
  reg signed [35:0] kconst_5;  // sfix36_En21
  wire signed [71:0] Gain1_mul_temp;  // sfix72_En35
  wire signed [35:0] Gain1_out1;  // sfix36_En14
  reg signed [35:0] Gain1_out1_1;  // sfix36_En14
  wire signed [35:0] Discrete_Time_Integrator_indtc;  // sfix36
  reg signed [35:0] Discrete_Time_Integrator_indtc_1;  // sfix36
  wire signed [71:0] gain_mul_temp_1;  // sfix72_En44
  wire signed [35:0] Discrete_Time_Integrator_u_gain;  // sfix36
  reg signed [35:0] Discrete_Time_Integrator_u_gain_1;  // sfix36
  wire signed [35:0] Discrete_Time_Integrator_u_dtc;  // sfix36_En14
  wire signed [35:0] Discrete_Time_Integrator_x_reg;  // sfix36_En14
  wire signed [35:0] Discrete_Time_Integrator_u_add;  // sfix36_En14
  reg signed [35:0] Discrete_Time_Integrator_reg_out;  // sfix36_En14
  wire signed [35:0] Sum_out1;  // sfix36_En14
  wire signed [35:0] Saturation_out1;  // sfix36_En14


  assign kconst = 36'sh540858E32;



  assign enb = clk_enable;

  always @(posedge clk or posedge reset_x)
    begin : HwModeRegister2_process
      if (reset_x == 1'b1) begin
        kconst_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end



  always @(posedge clk or posedge reset_x)
    begin : reduced_process
      if (reset_x == 1'b1) begin
        PID_OUT_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          PID_OUT_1 <= PID_OUT;
        end
      end
    end



  assign Gain_mul_temp = kconst_1 * PID_OUT_1;
  assign Gain_out1 = Gain_mul_temp[62:27];



  always @(posedge clk or posedge reset_x)
    begin : delayMatch1_process
      if (reset_x == 1'b1) begin
        delayMatch1_reg[0] <= 36'sh000000000;
        delayMatch1_reg[1] <= 36'sh000000000;
        delayMatch1_reg[2] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
          delayMatch1_reg[2] <= delayMatch1_reg_next[2];
        end
      end
    end

  assign Gain_out1_1 = delayMatch1_reg[2];
  assign delayMatch1_reg_next[0] = Gain_out1;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];
  assign delayMatch1_reg_next[2] = delayMatch1_reg[1];



  assign Discrete_Time_Integrator_reg_ctrl_co_1 = 1'b1;



  always @(posedge clk or posedge reset_x)
    begin : delayMatch_process
      if (reset_x == 1'b1) begin
        delayMatch_reg[0] <= 1'b0;
        delayMatch_reg[1] <= 1'b0;
        delayMatch_reg[2] <= 1'b0;
        delayMatch_reg[3] <= 1'b0;
        delayMatch_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
        end
      end
    end

  assign Discrete_Time_Integrator_reg_ctrl_de = delayMatch_reg[4];
  assign delayMatch_reg_next[0] = Discrete_Time_Integrator_reg_ctrl_co_1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];



  assign Discrete_Time_Integrator_reg_Initial_1 = 36'sh000004000;



  assign kconst_2 = 36'sh2DD451A23;



  always @(posedge clk or posedge reset_x)
    begin : HwModeRegister_process
      if (reset_x == 1'b1) begin
        kconst_3 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          kconst_3 <= kconst_2;
        end
      end
    end



  assign kconst_4 = 36'sh406FA68B0;



  always @(posedge clk or posedge reset_x)
    begin : HwModeRegister4_process
      if (reset_x == 1'b1) begin
        kconst_5 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          kconst_5 <= kconst_4;
        end
      end
    end



  assign Gain1_mul_temp = kconst_5 * PID_OUT_1;
  assign Gain1_out1 = Gain1_mul_temp[56:21];



  always @(posedge clk or posedge reset_x)
    begin : PipelineRegister2_process
      if (reset_x == 1'b1) begin
        Gain1_out1_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Gain1_out1_1 <= Gain1_out1;
        end
      end
    end



  assign Discrete_Time_Integrator_indtc = Gain1_out1_1;



  always @(posedge clk or posedge reset_x)
    begin : HwModeRegister1_process
      if (reset_x == 1'b1) begin
        Discrete_Time_Integrator_indtc_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_indtc_1 <= Discrete_Time_Integrator_indtc;
        end
      end
    end



  assign gain_mul_temp_1 = kconst_3 * Discrete_Time_Integrator_indtc_1;
  assign Discrete_Time_Integrator_u_gain = {{8{gain_mul_temp_1[71]}}, gain_mul_temp_1[71:44]};



  always @(posedge clk or posedge reset_x)
    begin : PipelineRegister_process
      if (reset_x == 1'b1) begin
        Discrete_Time_Integrator_u_gain_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_u_gain_1 <= Discrete_Time_Integrator_u_gain;
        end
      end
    end



  assign Discrete_Time_Integrator_u_dtc = Discrete_Time_Integrator_u_gain_1;



  assign Discrete_Time_Integrator_u_add = Discrete_Time_Integrator_x_reg + Discrete_Time_Integrator_u_dtc;



  always @(posedge clk or posedge reset_x)
    begin : Discrete_Time_Integrator_reg_process
      if (reset_x == 1'b1) begin
        Discrete_Time_Integrator_reg_out <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Discrete_Time_Integrator_reg_out <= Discrete_Time_Integrator_u_add;
        end
      end
    end



  assign Discrete_Time_Integrator_x_reg = (Discrete_Time_Integrator_reg_ctrl_de == 1'b0 ? 
    Discrete_Time_Integrator_reg_Initial_1 :
              Discrete_Time_Integrator_reg_out);



  assign Sum_out1 = Gain_out1_1 + Discrete_Time_Integrator_x_reg;



  assign Saturation_out1 = (Sum_out1 > 36'sh009C40000 ? 36'sh009C40000 :
              (Sum_out1 < 36'sh000000000 ? 36'sh000000000 :
              Sum_out1));



  assign Out1 = Saturation_out1;

  assign ce_out = clk_enable;

endmodule  // HANDMADE_PID

